/* Generated by Edge Impulse
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
// Generated on: 28.03.2023 09:30:35

#include <stdio.h>
#include <stdlib.h>
#include "edge-impulse-sdk/tensorflow/lite/c/builtin_op_data.h"
#include "edge-impulse-sdk/tensorflow/lite/c/common.h"
#include "edge-impulse-sdk/tensorflow/lite/micro/micro_mutable_op_resolver.h"
#include "edge-impulse-sdk/porting/ei_classifier_porting.h"

#if EI_CLASSIFIER_PRINT_STATE
#if defined(__cplusplus) && EI_C_LINKAGE == 1
extern "C" {
    extern void ei_printf(const char *format, ...);
}
#else
extern void ei_printf(const char *format, ...);
#endif
#endif

#if defined __GNUC__
#define ALIGN(X) __attribute__((aligned(X)))
#elif defined _MSC_VER
#define ALIGN(X) __declspec(align(X))
#elif defined __TASKING__
#define ALIGN(X) __align(X)
#endif

#ifndef EI_MAX_SCRATCH_BUFFER_COUNT
#define EI_MAX_SCRATCH_BUFFER_COUNT 4
#endif // EI_MAX_SCRATCH_BUFFER_COUNT

#ifndef EI_MAX_OVERFLOW_BUFFER_COUNT
#define EI_MAX_OVERFLOW_BUFFER_COUNT 10
#endif // EI_MAX_OVERFLOW_BUFFER_COUNT

using namespace tflite;
using namespace tflite::ops;
using namespace tflite::ops::micro;

namespace {

constexpr int kTensorArenaSize = 2672;

#if defined(EI_CLASSIFIER_ALLOCATION_STATIC)
uint8_t tensor_arena[kTensorArenaSize] ALIGN(16);
#elif defined(EI_CLASSIFIER_ALLOCATION_STATIC_HIMAX)
#pragma Bss(".tensor_arena")
uint8_t tensor_arena[kTensorArenaSize] ALIGN(16);
#pragma Bss()
#elif defined(EI_CLASSIFIER_ALLOCATION_STATIC_HIMAX_GNU)
uint8_t tensor_arena[kTensorArenaSize] ALIGN(16) __attribute__((section(".tensor_arena")));
#else
#define EI_CLASSIFIER_ALLOCATION_HEAP 1
uint8_t* tensor_arena = NULL;
#endif

static uint8_t* tensor_boundary;
static uint8_t* current_location;

template <int SZ, class T> struct TfArray {
  int sz; T elem[SZ];
};
enum used_operators_e {
  OP_RESHAPE, OP_CONV_2D, OP_MAX_POOL_2D, OP_FULLY_CONNECTED, OP_SOFTMAX,  OP_LAST
};
struct TensorInfo_t { // subset of TfLiteTensor used for initialization from constant memory
  TfLiteAllocationType allocation_type;
  TfLiteType type;
  void* data;
  TfLiteIntArray* dims;
  size_t bytes;
  TfLiteQuantization quantization;
};
struct NodeInfo_t { // subset of TfLiteNode used for initialization from constant memory
  struct TfLiteIntArray* inputs;
  struct TfLiteIntArray* outputs;
  void* builtin_data;
  used_operators_e used_op_index;
};

TfLiteContext ctx{};
TfLiteTensor tflTensors[23];
TfLiteEvalTensor tflEvalTensors[23];
TfLiteRegistration registrations[OP_LAST];
TfLiteNode tflNodes[11];

const TfArray<2, int> tensor_dimension0 = { 2, { 1,650 } };
const TfArray<1, float> quant0_scale = { 1, { 0.043145954608917236, } };
const TfArray<1, int> quant0_zero = { 1, { -11 } };
const TfLiteAffineQuantization quant0 = { (TfLiteFloatArray*)&quant0_scale, (TfLiteIntArray*)&quant0_zero, 0 };
const ALIGN(16) int32_t tensor_data1[4] = { 1, 1, 50, 13, };
const TfArray<1, int> tensor_dimension1 = { 1, { 4 } };
const ALIGN(16) int32_t tensor_data2[4] = { 1, 50, 1, 16, };
const TfArray<1, int> tensor_dimension2 = { 1, { 4 } };
const ALIGN(16) int32_t tensor_data3[4] = { 1, 1, 25, 16, };
const TfArray<1, int> tensor_dimension3 = { 1, { 4 } };
const ALIGN(16) int32_t tensor_data4[4] = { 1, 25, 1, 32, };
const TfArray<1, int> tensor_dimension4 = { 1, { 4 } };
const ALIGN(8) int32_t tensor_data5[2] = { -1, 416, };
const TfArray<1, int> tensor_dimension5 = { 1, { 2 } };
const ALIGN(16) int8_t tensor_data6[16*1*3*13] = { 
  /* [0][0][][] */ -49,0,1,12,-26,3,-72,-34,22,21,8,27,18, -25,-72,18,-32,35,-66,6,38,-35,-1,-10,15,-7, 4,-127,-34,-54,-1,9,3,-22,-36,7,-21,6,-17, 
  /* [1][0][][] */ -127,-119,7,49,74,109,55,10,6,6,13,-34,-57, -72,-22,-43,-42,-25,-36,-9,-30,-32,5,-80,-17,-9, -102,-4,16,-44,-61,84,-82,32,28,9,33,-37,-7, 
  /* [2][0][][] */ 127,18,-4,-96,-66,27,19,-32,20,112,0,-54,-23, -55,-28,-9,32,-58,10,87,31,-18,-9,-46,-52,-10, 0,-27,-80,-47,48,16,68,-29,15,-28,10,17,-1, 
  /* [3][0][][] */ -9,-120,120,127,67,86,35,36,55,54,1,44,54, 29,-106,116,53,24,-22,-4,25,30,28,47,79,-19, -24,-120,-7,-28,17,-15,-20,-21,-14,30,1,-18,-35, 
  /* [4][0][][] */ -33,15,-36,-90,-66,-13,-33,20,-28,-51,13,50,2, -98,0,-49,19,-52,-5,57,-26,23,-3,-52,-25,-10, -22,-127,34,-49,-119,-86,-43,56,-24,21,18,19,16, 
  /* [5][0][][] */ 78,-55,3,-21,87,119,7,-18,-12,-12,-7,5,-72, 127,-75,-13,-48,52,16,-6,-6,-44,-3,-11,14,-9, 102,-26,-53,-52,-81,-22,20,0,-1,-27,29,20,18, 
  /* [6][0][][] */ -90,-73,4,13,24,58,-10,-30,28,20,-2,6,34, -75,-2,-43,-36,-67,-72,-22,-27,-30,38,23,-15,-8, -5,-127,-53,-105,36,53,29,-1,-10,8,-7,28,6, 
  /* [7][0][][] */ -59,-87,-1,-13,-17,23,43,66,39,7,-35,9,12, -20,91,-30,-19,70,100,41,73,46,-18,49,14,-14, -72,127,90,74,87,61,92,103,27,-7,18,-2,11, 
  /* [8][0][][] */ 6,91,14,1,-18,4,-32,-28,-17,-33,55,-6,-1, -53,-23,127,5,0,2,-64,64,-36,49,-28,43,-18, -34,50,-16,20,-68,-62,36,-41,-51,100,23,-27,-17, 
  /* [9][0][][] */ -6,68,-90,-117,-65,7,-2,22,-29,-87,-31,-12,24, 78,88,1,-31,-4,-13,11,40,-55,-27,-82,27,41, -101,-89,-29,34,127,83,-19,-69,8,-61,-18,-8,-12, 
  /* [10][0][][] */ -77,0,-58,80,-55,127,55,1,28,51,-1,45,11, -112,47,13,-41,13,66,10,-34,42,-4,16,4,35, -97,77,44,75,32,-16,-3,-4,52,27,16,48,22, 
  /* [11][0][][] */ 0,45,-46,-40,-10,29,1,-66,-66,-21,64,26,-14, 2,42,-36,-63,-11,74,-9,12,-42,-38,59,-9,14, -127,92,2,-4,13,34,-25,-45,-33,27,1,21,18, 
  /* [12][0][][] */ 93,22,3,-10,-21,-8,120,61,40,-41,-11,41,46, -109,-45,-122,-94,35,59,0,127,22,-37,-49,50,10, -122,-75,-77,-5,19,81,40,-11,1,16,39,114,-17, 
  /* [13][0][][] */ 127,72,18,55,-15,24,-10,-8,-11,-23,-17,-41,26, 84,98,7,69,75,90,28,70,-13,-29,-62,75,-72, -67,16,-43,26,-70,-45,13,38,24,12,-27,-58,42, 
  /* [14][0][][] */ -8,-127,-43,30,62,35,-16,-2,8,-24,21,15,-30, 22,-1,-36,43,55,21,4,-1,4,35,-16,12,35, 6,43,-34,9,33,28,23,-42,28,-40,-60,-32,26, 
  /* [15][0][][] */ -127,-50,-3,16,-6,55,15,26,25,-15,4,-1,12, -92,18,-27,-15,-31,-32,5,-23,17,5,-20,11,3, -26,-9,-26,-29,-29,-68,0,5,-17,-8,37,-28,8, 
};
const TfArray<4, int> tensor_dimension6 = { 4, { 16,1,3,13 } };
const TfArray<16, float> quant6_scale = { 16, { 0.0098897656425833702, 0.0064032855443656445, 0.0055888653732836246, 0.0051753269508481026, 0.0068713584914803505, 0.0061734961345791817, 0.0077422517351806164, 0.0049579623155295849, 0.0050855819135904312, 0.0054741241037845612, 0.0062745809555053711, 0.006701628677546978, 0.0049307509325444698, 0.0040490562096238136, 0.0089197587221860886, 0.011673916131258011, } };
const TfArray<16, int> quant6_zero = { 16, { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 } };
const TfLiteAffineQuantization quant6 = { (TfLiteFloatArray*)&quant6_scale, (TfLiteIntArray*)&quant6_zero, 0 };
const ALIGN(16) int32_t tensor_data7[16] = { -833, -669, -5321, -3992, -2326, -5442, -74, -3698, -6346, -6109, -2669, -4267, -4308, -8600, -3595, -1397, };
const TfArray<1, int> tensor_dimension7 = { 1, { 16 } };
const TfArray<16, float> quant7_scale = { 16, { 0.00042670336551964283, 0.00027627588133327663, 0.00024113693507388234, 0.00022329442435875535, 0.00029647132032550871, 0.00026636137044988573, 0.00033404683927074075, 0.00021391602058429271, 0.00021942229068372399, 0.00023618631530553102, 0.00027072278317064047, 0.00028914815629832447, 0.00021274195751175284, 0.00017470039892941713, 0.00038485150435008109, 0.0005036822403781116, } };
const TfArray<16, int> quant7_zero = { 16, { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 } };
const TfLiteAffineQuantization quant7 = { (TfLiteFloatArray*)&quant7_scale, (TfLiteIntArray*)&quant7_zero, 0 };
const ALIGN(16) int8_t tensor_data8[32*1*3*16] = { 
  /* [0][0][][] */ 10,7,4,3,7,-3,-8,-28,-31,-29,20,9,-28,-94,-36,-1, -4,2,-84,-69,-66,-35,-7,-13,-104,-71,-20,-5,-32,-115,28,-18, -53,-49,-106,-23,-127,87,-75,-41,-16,-5,-54,-34,21,-3,-68,-76, 
  /* [1][0][][] */ -66,-127,-11,-3,-13,13,-88,3,-16,54,-17,-15,-4,14,-27,-44, -87,-12,26,-20,-15,-24,-58,15,-21,23,-36,18,0,-11,25,-103, -22,-15,-51,15,-71,-5,5,-5,-16,-54,81,21,1,-20,-15,-3, 
  /* [2][0][][] */ 12,-58,-33,-20,-10,-29,16,-100,6,7,-63,-25,23,21,-15,-51, -49,-18,30,-37,1,40,-26,-77,-6,-3,-111,-46,29,3,13,-78, 18,8,-14,20,-11,32,81,-127,-27,13,-122,-5,-6,-61,4,-14, 
  /* [3][0][][] */ -97,-36,-97,-67,15,-42,22,39,2,-87,8,-9,-19,-12,3,7, -34,8,-62,-71,-54,13,-23,-73,-62,0,-52,23,-28,-59,-40,-24, -67,-102,-40,-32,-67,19,-38,-10,-16,127,-9,8,-34,5,-94,-29, 
  /* [4][0][][] */ -99,-107,-10,-85,-21,-25,-127,-8,-4,2,-30,-29,14,5,-48,-44, -42,-17,17,-89,-38,-30,-42,-2,-4,-6,-29,-5,25,-8,7,-56, -31,10,-16,-6,-52,-8,-4,20,-63,24,22,17,11,-1,20,-18, 
  /* [5][0][][] */ -28,-52,-25,-15,7,-127,-57,-56,10,-11,-10,-89,-97,-10,-7,-53, -105,-94,7,-29,1,-110,-80,-6,-10,-48,24,-71,-40,-11,-29,-5, -40,23,21,-12,-9,-11,-19,30,-78,16,16,-8,12,-3,15,-31, 
  /* [6][0][][] */ 15,9,-24,13,13,-16,8,-28,-86,-29,-72,-85,-6,-49,10,-11, -5,12,3,-9,-34,19,3,-15,-69,-35,-29,-38,-28,-59,-9,-87, -2,-18,15,30,-81,53,-36,-11,-103,-84,4,-14,-71,-40,2,-127, 
  /* [7][0][][] */ 2,11,-45,12,-3,-31,-2,21,-127,-11,9,-65,-1,-66,8,-11, 0,-3,-53,22,-88,-20,2,-5,-99,-23,20,-10,9,-28,-52,-33, -116,-41,-6,-22,-94,65,-62,44,-59,-58,16,-1,-31,10,15,-105, 
  /* [8][0][][] */ -40,-38,-14,69,-106,3,-31,18,-13,-17,16,-26,9,-6,24,-44, -85,-33,9,-23,-94,1,-90,6,5,-1,2,12,-18,-6,-13,-78, -61,-118,17,-43,8,24,-127,-14,7,8,-13,14,-10,0,-72,-41, 
  /* [9][0][][] */ -105,-39,32,-5,-21,25,-41,-20,17,-29,17,-7,-18,-78,-64,-14, -19,-75,32,17,-27,32,-80,8,-11,-62,-99,117,-50,-33,22,0, -69,-42,4,-11,-37,-23,-78,35,21,-127,14,-46,-37,-46,13,-22, 
  /* [10][0][][] */ 8,-7,-103,-64,58,-46,-26,11,54,-88,11,0,-37,-44,-3,8, -34,-35,-60,-44,-23,-19,-6,-23,-9,-116,-56,-124,-52,48,-52,-107, -7,-28,-17,-70,-14,-44,16,-5,1,-86,-127,-84,-71,5,-52,12, 
  /* [11][0][][] */ 23,-28,-97,2,0,-118,45,-28,-5,-127,42,9,-72,-16,3,-48, -67,20,-58,-25,-12,-28,-39,38,-7,-108,31,-48,-16,15,-104,-12, -54,-19,8,-27,-29,27,-39,-48,-3,-119,-33,-95,-54,48,-112,18, 
  /* [12][0][][] */ 0,-39,30,-103,-1,9,-43,-23,-4,33,-52,32,-65,67,-95,-45, -4,-17,-6,-118,27,-65,-7,-120,-7,7,-89,-39,-113,-35,-127,-10, 4,-15,-96,11,52,-105,11,-90,-2,-36,-58,-41,-34,-69,-49,0, 
  /* [13][0][][] */ 1,-4,-91,-34,-19,13,-18,-58,-81,1,-5,72,5,-11,-23,-16, -24,20,-96,-48,21,-33,-11,-30,-127,13,-5,-12,-51,-37,85,-11, -37,-2,-43,-30,19,28,-41,-29,-67,26,-64,20,-80,20,21,-24, 
  /* [14][0][][] */ -19,37,-46,-3,0,-12,-15,-7,-13,-7,27,9,3,-25,3,33, -17,-20,0,-80,12,-46,-29,-82,21,-42,-14,-15,-81,20,-44,-41, -90,-83,0,-24,-49,-61,-86,-127,1,-50,5,-26,-9,-2,-48,-84, 
  /* [15][0][][] */ -68,-42,34,-16,-21,-6,-100,-5,-14,6,-15,-3,16,-14,-58,-60, -36,-68,-25,3,-40,-39,-41,3,-96,13,25,-24,8,-19,-42,-127, 0,-6,-70,24,-11,-47,14,18,-101,-33,-21,-18,39,-31,14,-8, 
  /* [16][0][][] */ -2,0,-80,-22,16,-92,7,-3,-46,-19,14,8,-72,-65,-127,16, 7,-17,-87,-53,13,-66,-1,-30,-24,10,-2,1,-14,-91,-81,-3, -1,-2,-71,-30,0,-16,27,41,-50,-33,6,-3,-9,-62,-53,0, 
  /* [17][0][][] */ -22,-127,-13,-4,3,-71,-52,-113,1,-4,5,-55,-11,14,-65,-88, 16,-69,-38,7,3,-21,-2,-83,-7,0,-64,-45,-18,13,-33,-47, 31,-11,-27,1,3,32,12,-50,-19,-6,-62,-8,-19,-40,8,-58, 
  /* [18][0][][] */ -97,-64,61,-23,-37,-31,-101,-13,-56,3,35,-47,-89,-2,7,-39, -62,-50,-56,-19,-84,-33,-71,23,-7,39,13,88,33,6,-37,-22, -7,4,-127,-3,-70,-16,-26,18,-26,-15,16,-42,35,-3,41,14, 
  /* [19][0][][] */ 13,-43,-7,-17,-50,-11,11,0,-87,30,-67,-105,-41,-10,-35,-35, -10,4,6,-19,-17,52,-29,-35,-91,13,-88,-56,65,-18,-10,-21, -35,-41,-24,-45,32,-7,-34,-16,-127,36,-126,-16,21,-80,-61,-39, 
  /* [20][0][][] */ -61,-27,-119,18,-51,-11,-43,7,28,-12,25,66,-9,-9,2,-25, 9,-16,-59,-4,-35,-27,-8,-2,-14,-94,22,-38,-48,-84,-21,-48, 2,-3,-26,8,-50,-73,-1,-12,3,-83,-5,-9,-45,-127,20,-31, 
  /* [21][0][][] */ 5,14,12,-12,-7,2,-6,-27,11,-48,-10,-11,6,-11,7,17, -56,2,12,-26,2,-7,-34,-47,10,-83,10,-22,-50,-35,-11,13, -56,-72,7,-20,-12,-58,-84,-80,2,-6,-127,-44,2,46,-66,-57, 
  /* [22][0][][] */ 4,-6,-25,38,-33,-6,3,3,-10,-12,9,-50,-23,-18,36,-22, -46,2,18,-2,-88,-19,-23,-127,-11,-42,5,21,-57,-33,2,-41, -82,-73,18,-25,-8,27,-47,0,3,-32,-92,28,-17,-21,-56,-40, 
  /* [23][0][][] */ -31,-122,-11,-33,-53,31,-42,-127,-3,-21,-60,-5,-93,-3,16,-95, 22,-83,-12,16,-107,4,-36,-107,0,-62,-89,-18,-69,2,-15,-99, 64,-21,-42,16,49,21,-12,2,-6,-9,7,1,2,-33,6,-38, 
  /* [24][0][][] */ 24,-40,-20,73,24,91,-32,25,19,-28,-71,40,-59,-17,-62,-46, 5,-99,-3,13,12,-29,-59,-17,-55,35,-35,-7,-40,4,53,-93, -62,-59,-81,-46,15,-127,-46,-43,-39,-26,-23,47,-56,-14,27,-9, 
  /* [25][0][][] */ -23,26,-19,-79,10,-41,-2,-77,-10,-31,-29,-32,6,-8,-52,12, -54,-36,23,-71,-23,-56,-29,-78,31,-99,-64,-1,-42,6,-66,-3, 22,-107,16,-99,-15,-38,-56,-22,2,-41,-113,-127,37,9,-43,-64, 
  /* [26][0][][] */ 33,-3,-22,9,19,63,3,-14,-122,-28,-15,-24,21,-50,-14,6, -22,4,3,-6,-52,-2,-1,32,-127,-49,-6,-14,-15,5,22,-15, -89,-56,-11,3,-103,-9,-117,-3,-23,-3,7,12,-38,30,42,-72, 
  /* [27][0][][] */ 5,-111,53,-14,-12,-6,-68,1,-75,56,-80,-63,-34,7,102,-100, -79,-125,-50,-98,-127,-24,-50,-41,-92,14,5,-31,-30,-8,22,-53, -1,-92,-57,-13,-72,0,-58,29,-65,0,-65,-5,20,11,-30,10, 
  /* [28][0][][] */ 3,-19,-27,23,-1,10,-41,54,-43,5,24,7,-38,-7,41,-52, -29,-78,-19,18,-6,-7,-71,-7,0,26,-13,33,-63,9,2,-3, -74,-127,23,-18,19,-1,-101,-29,-1,27,-27,6,-28,2,42,-9, 
  /* [29][0][][] */ -2,-17,-3,-19,-25,17,4,-7,-21,-36,-15,5,-3,-82,12,-75, 4,-6,-8,-10,-16,-7,-1,-20,-49,1,-15,-20,6,-127,-6,-51, 3,-5,14,-15,-38,-1,2,2,-102,7,-2,-3,37,-116,10,-31, 
  /* [30][0][][] */ -127,-99,-14,-89,7,-9,-104,-45,13,-22,-19,11,62,-20,-105,-5, -65,-92,-5,20,-28,3,-29,-25,-2,19,21,1,-31,-3,-49,-29, -25,-3,27,-13,-36,-26,-36,21,-27,12,34,30,33,3,-8,-81, 
  /* [31][0][][] */ -11,33,-26,-5,-62,-73,-7,-15,-34,-95,11,6,-10,-127,27,-24, 14,-4,-64,-6,-111,-48,2,-10,14,-25,-8,11,-7,-116,14,-14, -8,18,-56,-10,-44,-41,-7,-7,-9,-52,26,17,-9,-99,33,-7, 
};
const TfArray<4, int> tensor_dimension8 = { 4, { 32,1,3,16 } };
const TfArray<32, float> quant8_scale = { 32, { 0.0086944187059998512, 0.0095223812386393547, 0.0077896891161799431, 0.0060950606130063534, 0.012602979317307472, 0.011751965619623661, 0.0098239649087190628, 0.0090017765760421753, 0.013213012367486954, 0.0070440536364912987, 0.0076037505641579628, 0.0067451535724103451, 0.0075174304656684399, 0.00756092369556427, 0.010544418357312679, 0.010355585254728794, 0.010572979226708412, 0.013029768131673336, 0.0074555161409080029, 0.0084089264273643494, 0.0093343453481793404, 0.011214757338166237, 0.011176290921866894, 0.0097538111731410027, 0.0073237763717770576, 0.009828704409301281, 0.010748168453574181, 0.0073980255983769894, 0.010593428276479244, 0.014966502785682678, 0.010535652749240398, 0.010854865424335003, } };
const TfArray<32, int> quant8_zero = { 32, { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 } };
const TfLiteAffineQuantization quant8 = { (TfLiteFloatArray*)&quant8_scale, (TfLiteIntArray*)&quant8_zero, 0 };
const ALIGN(16) int32_t tensor_data9[32] = { -2064, -888, 378, -2271, 74, 276, -351, -1371, -1138, -740, -51, -512, -458, -1784, -385, -150, 24, 235, -408, -369, -204, -129, -796, -197, -1002, 605, -1622, -1964, -1761, 220, 205, -731, };
const TfArray<1, int> tensor_dimension9 = { 1, { 32 } };
const TfArray<32, float> quant9_scale = { 32, { 0.00047783975605852902, 0.00052334403153508902, 0.00042811638559214771, 0.00033498066477477551, 0.00069265178171917796, 0.00064588058739900589, 0.00053991889581084251, 0.00049473193939775229, 0.00072617881232872605, 0.00038713673711754382, 0.00041789733222685754, 0.00037070937105454504, 0.00041315323323942721, 0.00041554358904249966, 0.00057951454073190689, 0.00056913640582934022, 0.00058108422672376037, 0.00071610783925279975, 0.00040975044248625636, 0.00046214926987886429, 0.00051300972700119019, 0.00061635597376152873, 0.00061424187151715159, 0.00053606327855959535, 0.00040251010796055198, 0.00054017937509343028, 0.00059071253053843975, 0.00040659081423655152, 0.0005822081002406776, 0.00082254951121285558, 0.00057903281413018703, 0.0005965765449218452, } };
const TfArray<32, int> quant9_zero = { 32, { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 } };
const TfLiteAffineQuantization quant9 = { (TfLiteFloatArray*)&quant9_scale, (TfLiteIntArray*)&quant9_zero, 0 };
const ALIGN(16) int8_t tensor_data10[3*416] = { 
  16, -7, 1, -6, 7, -2, 9, 12, 63, -52, -105, -22, 45, 5, -19, 0, 12, 8, 5, 3, 39, -106, -1, -13, -90, -61, 24, 41, 44, 14, -7, -10, -27, -50, 12, -24, 20, -34, 31, 36, 29, -18, -78, 1, -72, -16, -45, -67, 19, 39, -19, -18, -14, -35, 8, 36, -36, -94, 46, 28, 22, 8, -14, -21, -21, 25, 4, 38, -36, 8, 24, 44, 71, 12, -54, -9, -12, -16, -103, -28, -1, 31, 24, -39, -22, -55, 24, 31, 45, -123, 14, 2, 64, 26, 12, -39, 28, 37, 35, 66, 24, -31, 19, 24, 63, -18, -60, 5, 28, 48, -82, 21, -11, -6, 18, 63, 7, -39, 37, 7, 38, -58, 34, 36, 33, -14, -12, -20, -5, 8, -18, 40, -10, 32, 8, 27, 46, 1, -54, -10, 46, -12, -52, -38, 1, -30, -1, -4, -29, -41, 12, -9, 50, -30, 30, 21, 26, -38, -16, 11, 57, 19, -36, 23, -9, 0, 27, 12, 64, 11, -24, 4, 42, 30, -43, -4, 10, -19, 19, -11, 3, -58, 22, 6, 19, -58, 49, 17, 41, -10, -9, -38, 56, 4, -4, 2, -2, 6, 42, 43, 42, 2, -57, 23, -16, 24, -39, -3, 8, -35, 30, 9, -10, -8, 26, 29, 31, -47, 36, -24, 39, -28, 14, -14, -8, 3, -34, 30, 3, 10, 27, 28, 38, -3, -64, 28, 23, 35, -59, -17, 10, -16, 15, -36, 22, -32, 42, -4, 37, -42, 40, 18, 22, -32, 0, -21, 12, 23, -2, 25, -4, 5, 27, 50, 64, 17, -24, -11, 50, 2, -23, 7, -3, 0, 8, -3, 25, -81, 41, 11, 18, -46, 49, 16, 35, -42, 15, -28, -6, 11, -17, -15, 23, 19, 24, 23, 35, -13, -51, 44, -9, -35, -124, -19, 22, -1, 17, 14, 0, -74, 48, 66, 23, -18, 21, 27, 27, -46, 18, -11, 47, 23, -28, -27, -45, 12, 19, 31, 48, 16, -5, 25, 3, 13, -74, -3, -7, -58, -6, -16, -10, -62, -19, 15, 12, 11, 17, 26, 51, -76, 27, -17, -22, -14, -6, 62, 15, 55, 8, -8, 29, 12, -36, 33, -1, 14, -34, -9, 17, 15, 10, -50, -23, -34, -4, -8, 15, 5, 15, 5, 46, -22, 1, 4, -13, 38, -34, -29, -51, 46, -23, -7, 18, 10, 22, 22, 26, -63, 9, -40, 58, -95, -22, -5, -3, 3, 22, 32, 28, 4, -2, -34, 1, -26, 4, -24, 
  -9, -24, -4, 33, 3, -11, -7, -23, 14, 34, 30, 23, -33, -48, 5, 5, 0, 13, 22, -13, -23, 43, 38, 0, 14, 14, -51, -49, 9, -7, -22, 29, -106, 0, -32, 16, -23, -4, -42, -45, -5, -18, 55, 9, 61, 22, 12, 4, -16, 2, -2, -15, 23, 18, -24, -31, -10, 56, -36, -74, -32, -22, -8, 11, 57, 0, -5, -53, 17, -60, -51, -20, -38, -56, 32, 11, 54, 0, 19, 48, 21, 26, -40, -46, 22, 7, -1, 18, -5, 22, 15, -7, -21, -4, -11, 27, -19, -81, 8, -8, -56, -9, -30, -8, -24, -27, 23, 8, 22, -24, 24, -36, -3, 51, -50, -39, 10, 7, -23, 56, -112, 41, -30, -6, -14, 8, -20, 5, 47, -57, 38, -55, -4, -58, -21, -25, -37, -15, 33, 42, 18, 20, 22, 13, -24, 43, -51, 45, 41, 24, -6, 9, -10, 17, -35, -31, -17, 13, -30, 20, -13, -70, 46, -28, -39, -61, 14, -25, -28, -63, 19, 35, 14, -62, 37, -34, -14, 49, -84, 11, -43, 22, -1, 24, -32, 14, -34, -6, -16, 11, -22, 8, -40, -30, 23, -14, -78, -47, -5, -37, -8, -47, 14, -13, 16, -52, 38, -54, -3, 61, -81, 3, -54, 6, 26, 20, -51, 19, 2, -20, -40, 42, -35, 16, 31, -62, 23, 9, -37, -39, 1, -14, 5, -42, 24, -1, -1, -18, 8, -16, -17, 47, -43, 8, -35, 14, -31, 7, -32, 32, -7, -51, 10, 43, -49, 42, -44, -62, 39, -99, -46, 4, 2, -45, -23, -41, 32, 30, 5, -27, -2, -32, 6, 40, -54, -19, -77, 6, -67, -5, -28, -25, -4, -111, -84, 43, -57, -7, -29, -65, 19, -20, -78, -54, 25, -8, -109, -71, 5, -68, 2, 17, 60, 10, -41, 48, -33, 11, -4, 41, -61, 14, -20, 28, -20, -99, -45, 17, -70, 9, -8, -18, 4, -2, -4, -91, 36, -25, 4, -87, -20, -79, -1, -13, 29, -29, -18, 30, -23, 12, -46, 3, 27, 22, -31, 41, 3, -39, -67, 42, -48, 25, -37, -6, 19, -61, -11, -106, 10, -8, -32, -57, -13, -38, 5, -24, -46, 34, 21, 41, -5, 41, 1, 24, -26, 29, -7, -27, 14, 14, -38, 31, 2, 17, -26, -92, 22, 9, -82, -67, 4, 13, 13, -12, 16, 20, -3, 38, -18, 47, -32, 49, 5, 0, 5, -16, 42, -20, -30, -64, 3, 49, -3, 24, 56, 9, 
  -19, 18, 12, -25, 11, 19, -5, 20, -101, 7, 18, 0, -27, 46, 11, -13, -58, 12, -21, 14, 13, 45, -63, -5, 50, 37, -2, 16, -51, 5, 26, -16, 66, 67, 44, -14, 9, 37, -15, 14, -21, 20, 6, -18, 7, -32, 13, 78, -29, -54, 23, 23, -39, 0, 9, -5, 38, 26, -29, -7, -4, -6, 31, 15, -9, 17, 11, -18, 36, 55, 24, -30, -66, 36, 19, -19, -32, -11, 15, -18, -17, -50, 31, 59, 16, 19, -15, -30, -41, 45, -31, -6, -40, -17, 23, 3, -34, 25, -17, -49, 23, 57, 9, -1, -40, 44, -4, -4, -32, -25, 15, 44, -21, -45, 11, -43, -1, 31, 7, -56, 3, 19, -22, -41, -24, 4, 40, -3, -48, 30, -30, 4, 23, 21, -6, 13, -16, 18, 32, -34, -47, -27, 5, 38, -7, -22, 24, -30, -5, 5, -5, 4, 0, 19, -22, 26, -23, 20, 25, -1, -82, 36, 1, -11, 15, 48, -33, -7, -47, 30, 5, -20, -23, 6, 34, 35, 0, -72, 17, -6, 46, 38, -40, -58, -13, 37, -30, -34, -20, -9, 23, 25, -25, 21, -35, 3, 32, 31, -32, 5, -48, 21, 42, -14, -11, -11, 2, 52, -15, -41, 35, 5, 15, -4, -32, -83, 1, 22, -22, 14, -11, -33, 33, -14, -61, 22, 15, -16, 36, 32, -61, 13, -61, 10, 20, 11, -25, -35, 24, 37, 6, -39, 16, 39, 18, 27, -53, -40, -25, 10, -30, 24, -37, -7, 30, -3, 24, 29, -28, 51, 18, 21, -47, -9, -10, 23, 18, 16, -52, 21, 9, 20, 6, -40, 17, 18, 34, 33, 19, -18, 9, 44, -29, 23, 30, -4, 35, 9, 28, 22, 16, 9, 39, 18, -78, -26, 20, 29, 27, 16, -10, 0, 19, 15, -5, -42, 11, -4, 22, 1, 7, -127, -11, 10, -3, 8, -9, 13, 33, 0, -94, 30, -7, 8, 14, 58, -85, -47, -29, 41, 35, 3, -7, -5, 6, 9, 9, 7, 37, 7, 27, 41, -12, -46, -5, -29, -17, -5, 4, -14, 24, 7, 51, 19, -6, -3, 2, 40, 1, -24, 0, 21, 62, 22, -51, -17, 63, -22, -23, -31, -6, 5, 17, -8, 13, -36, -29, 14, -11, -38, -14, 6, 26, -7, 35, 56, 22, 59, 75, 7, 31, -24, -13, -3, -34, -22, -51, 21, 23, -26, -4, 1, 48, 32, -9, 7, -31, -22, -2, 50, -21, -38, -9, -5, -64, 0, 
};
const TfArray<2, int> tensor_dimension10 = { 2, { 3,416 } };
const TfArray<1, float> quant10_scale = { 1, { 0.0074438704177737236, } };
const TfArray<1, int> quant10_zero = { 1, { 0 } };
const TfLiteAffineQuantization quant10 = { (TfLiteFloatArray*)&quant10_scale, (TfLiteIntArray*)&quant10_zero, 0 };
const ALIGN(8) int32_t tensor_data11[3] = { -937, 2380, -1434, };
const TfArray<1, int> tensor_dimension11 = { 1, { 3 } };
const TfArray<1, float> quant11_scale = { 1, { 0.00033298222115263343, } };
const TfArray<1, int> quant11_zero = { 1, { 0 } };
const TfLiteAffineQuantization quant11 = { (TfLiteFloatArray*)&quant11_scale, (TfLiteIntArray*)&quant11_zero, 0 };
const TfArray<4, int> tensor_dimension12 = { 4, { 1,1,50,13 } };
const TfArray<1, float> quant12_scale = { 1, { 0.043145954608917236, } };
const TfArray<1, int> quant12_zero = { 1, { -11 } };
const TfLiteAffineQuantization quant12 = { (TfLiteFloatArray*)&quant12_scale, (TfLiteIntArray*)&quant12_zero, 0 };
const TfArray<4, int> tensor_dimension13 = { 4, { 1,1,50,16 } };
const TfArray<1, float> quant13_scale = { 1, { 0.054959367960691452, } };
const TfArray<1, int> quant13_zero = { 1, { -128 } };
const TfLiteAffineQuantization quant13 = { (TfLiteFloatArray*)&quant13_scale, (TfLiteIntArray*)&quant13_zero, 0 };
const TfArray<4, int> tensor_dimension14 = { 4, { 1,50,1,16 } };
const TfArray<1, float> quant14_scale = { 1, { 0.054959367960691452, } };
const TfArray<1, int> quant14_zero = { 1, { -128 } };
const TfLiteAffineQuantization quant14 = { (TfLiteFloatArray*)&quant14_scale, (TfLiteIntArray*)&quant14_zero, 0 };
const TfArray<4, int> tensor_dimension15 = { 4, { 1,25,1,16 } };
const TfArray<1, float> quant15_scale = { 1, { 0.054959367960691452, } };
const TfArray<1, int> quant15_zero = { 1, { -128 } };
const TfLiteAffineQuantization quant15 = { (TfLiteFloatArray*)&quant15_scale, (TfLiteIntArray*)&quant15_zero, 0 };
const TfArray<4, int> tensor_dimension16 = { 4, { 1,1,25,16 } };
const TfArray<1, float> quant16_scale = { 1, { 0.054959367960691452, } };
const TfArray<1, int> quant16_zero = { 1, { -128 } };
const TfLiteAffineQuantization quant16 = { (TfLiteFloatArray*)&quant16_scale, (TfLiteIntArray*)&quant16_zero, 0 };
const TfArray<4, int> tensor_dimension17 = { 4, { 1,1,25,32 } };
const TfArray<1, float> quant17_scale = { 1, { 0.044732403010129929, } };
const TfArray<1, int> quant17_zero = { 1, { -128 } };
const TfLiteAffineQuantization quant17 = { (TfLiteFloatArray*)&quant17_scale, (TfLiteIntArray*)&quant17_zero, 0 };
const TfArray<4, int> tensor_dimension18 = { 4, { 1,25,1,32 } };
const TfArray<1, float> quant18_scale = { 1, { 0.044732403010129929, } };
const TfArray<1, int> quant18_zero = { 1, { -128 } };
const TfLiteAffineQuantization quant18 = { (TfLiteFloatArray*)&quant18_scale, (TfLiteIntArray*)&quant18_zero, 0 };
const TfArray<4, int> tensor_dimension19 = { 4, { 1,13,1,32 } };
const TfArray<1, float> quant19_scale = { 1, { 0.044732403010129929, } };
const TfArray<1, int> quant19_zero = { 1, { -128 } };
const TfLiteAffineQuantization quant19 = { (TfLiteFloatArray*)&quant19_scale, (TfLiteIntArray*)&quant19_zero, 0 };
const TfArray<2, int> tensor_dimension20 = { 2, { 1,416 } };
const TfArray<1, float> quant20_scale = { 1, { 0.044732403010129929, } };
const TfArray<1, int> quant20_zero = { 1, { -128 } };
const TfLiteAffineQuantization quant20 = { (TfLiteFloatArray*)&quant20_scale, (TfLiteIntArray*)&quant20_zero, 0 };
const TfArray<2, int> tensor_dimension21 = { 2, { 1,3 } };
const TfArray<1, float> quant21_scale = { 1, { 0.11360900104045868, } };
const TfArray<1, int> quant21_zero = { 1, { -2 } };
const TfLiteAffineQuantization quant21 = { (TfLiteFloatArray*)&quant21_scale, (TfLiteIntArray*)&quant21_zero, 0 };
const TfArray<2, int> tensor_dimension22 = { 2, { 1,3 } };
const TfArray<1, float> quant22_scale = { 1, { 0.00390625, } };
const TfArray<1, int> quant22_zero = { 1, { -128 } };
const TfLiteAffineQuantization quant22 = { (TfLiteFloatArray*)&quant22_scale, (TfLiteIntArray*)&quant22_zero, 0 };
const TfLiteReshapeParams opdata0 = { { 0, 0, 0, 0, 0, 0, 0, 0, }, 0 };
const TfArray<2, int> inputs0 = { 2, { 0,1 } };
const TfArray<1, int> outputs0 = { 1, { 12 } };
const TfLiteConvParams opdata1 = { kTfLitePaddingSame, 1,1, kTfLiteActRelu, 1,1 };
const TfArray<3, int> inputs1 = { 3, { 12,6,7 } };
const TfArray<1, int> outputs1 = { 1, { 13 } };
const TfLiteReshapeParams opdata2 = { { 0, 0, 0, 0, 0, 0, 0, 0, }, 0 };
const TfArray<2, int> inputs2 = { 2, { 13,2 } };
const TfArray<1, int> outputs2 = { 1, { 14 } };
const TfLitePoolParams opdata3 = { kTfLitePaddingSame, 1,2, 1,2, kTfLiteActNone, { { 0,0, 0, 0 } } };
const TfArray<1, int> inputs3 = { 1, { 14 } };
const TfArray<1, int> outputs3 = { 1, { 15 } };
const TfLiteReshapeParams opdata4 = { { 0, 0, 0, 0, 0, 0, 0, 0, }, 0 };
const TfArray<2, int> inputs4 = { 2, { 15,3 } };
const TfArray<1, int> outputs4 = { 1, { 16 } };
const TfLiteConvParams opdata5 = { kTfLitePaddingSame, 1,1, kTfLiteActRelu, 1,1 };
const TfArray<3, int> inputs5 = { 3, { 16,8,9 } };
const TfArray<1, int> outputs5 = { 1, { 17 } };
const TfLiteReshapeParams opdata6 = { { 0, 0, 0, 0, 0, 0, 0, 0, }, 0 };
const TfArray<2, int> inputs6 = { 2, { 17,4 } };
const TfArray<1, int> outputs6 = { 1, { 18 } };
const TfLitePoolParams opdata7 = { kTfLitePaddingSame, 1,2, 1,2, kTfLiteActNone, { { 0,0, 0, 0 } } };
const TfArray<1, int> inputs7 = { 1, { 18 } };
const TfArray<1, int> outputs7 = { 1, { 19 } };
const TfLiteReshapeParams opdata8 = { { 0, 0, 0, 0, 0, 0, 0, 0, }, 0 };
const TfArray<2, int> inputs8 = { 2, { 19,5 } };
const TfArray<1, int> outputs8 = { 1, { 20 } };
const TfLiteFullyConnectedParams opdata9 = { kTfLiteActNone, kTfLiteFullyConnectedWeightsFormatDefault, false, false };
const TfArray<3, int> inputs9 = { 3, { 20,10,11 } };
const TfArray<1, int> outputs9 = { 1, { 21 } };
const TfLiteSoftmaxParams opdata10 = { 1 };
const TfArray<1, int> inputs10 = { 1, { 21 } };
const TfArray<1, int> outputs10 = { 1, { 22 } };
const TensorInfo_t tensorData[] = {
  { kTfLiteArenaRw, kTfLiteInt8, tensor_arena + 656, (TfLiteIntArray*)&tensor_dimension0, 650, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&quant0))}, },
  { kTfLiteMmapRo, kTfLiteInt32, (void*)tensor_data1, (TfLiteIntArray*)&tensor_dimension1, 16, {kTfLiteNoQuantization, nullptr}, },
  { kTfLiteMmapRo, kTfLiteInt32, (void*)tensor_data2, (TfLiteIntArray*)&tensor_dimension2, 16, {kTfLiteNoQuantization, nullptr}, },
  { kTfLiteMmapRo, kTfLiteInt32, (void*)tensor_data3, (TfLiteIntArray*)&tensor_dimension3, 16, {kTfLiteNoQuantization, nullptr}, },
  { kTfLiteMmapRo, kTfLiteInt32, (void*)tensor_data4, (TfLiteIntArray*)&tensor_dimension4, 16, {kTfLiteNoQuantization, nullptr}, },
  { kTfLiteMmapRo, kTfLiteInt32, (void*)tensor_data5, (TfLiteIntArray*)&tensor_dimension5, 8, {kTfLiteNoQuantization, nullptr}, },
  { kTfLiteMmapRo, kTfLiteInt8, (void*)tensor_data6, (TfLiteIntArray*)&tensor_dimension6, 624, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&quant6))}, },
  { kTfLiteMmapRo, kTfLiteInt32, (void*)tensor_data7, (TfLiteIntArray*)&tensor_dimension7, 64, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&quant7))}, },
  { kTfLiteMmapRo, kTfLiteInt8, (void*)tensor_data8, (TfLiteIntArray*)&tensor_dimension8, 1536, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&quant8))}, },
  { kTfLiteMmapRo, kTfLiteInt32, (void*)tensor_data9, (TfLiteIntArray*)&tensor_dimension9, 128, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&quant9))}, },
  { kTfLiteMmapRo, kTfLiteInt8, (void*)tensor_data10, (TfLiteIntArray*)&tensor_dimension10, 1248, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&quant10))}, },
  { kTfLiteMmapRo, kTfLiteInt32, (void*)tensor_data11, (TfLiteIntArray*)&tensor_dimension11, 12, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&quant11))}, },
  { kTfLiteArenaRw, kTfLiteInt8, tensor_arena + 0, (TfLiteIntArray*)&tensor_dimension12, 650, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&quant12))}, },
  { kTfLiteArenaRw, kTfLiteInt8, tensor_arena + 800, (TfLiteIntArray*)&tensor_dimension13, 800, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&quant13))}, },
  { kTfLiteArenaRw, kTfLiteInt8, tensor_arena + 0, (TfLiteIntArray*)&tensor_dimension14, 800, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&quant14))}, },
  { kTfLiteArenaRw, kTfLiteInt8, tensor_arena + 800, (TfLiteIntArray*)&tensor_dimension15, 400, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&quant15))}, },
  { kTfLiteArenaRw, kTfLiteInt8, tensor_arena + 0, (TfLiteIntArray*)&tensor_dimension16, 400, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&quant16))}, },
  { kTfLiteArenaRw, kTfLiteInt8, tensor_arena + 800, (TfLiteIntArray*)&tensor_dimension17, 800, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&quant17))}, },
  { kTfLiteArenaRw, kTfLiteInt8, tensor_arena + 0, (TfLiteIntArray*)&tensor_dimension18, 800, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&quant18))}, },
  { kTfLiteArenaRw, kTfLiteInt8, tensor_arena + 800, (TfLiteIntArray*)&tensor_dimension19, 416, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&quant19))}, },
  { kTfLiteArenaRw, kTfLiteInt8, tensor_arena + 0, (TfLiteIntArray*)&tensor_dimension20, 416, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&quant20))}, },
  { kTfLiteArenaRw, kTfLiteInt8, tensor_arena + 416, (TfLiteIntArray*)&tensor_dimension21, 3, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&quant21))}, },
  { kTfLiteArenaRw, kTfLiteInt8, tensor_arena + 0, (TfLiteIntArray*)&tensor_dimension22, 3, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&quant22))}, },
};const NodeInfo_t nodeData[] = {
  { (TfLiteIntArray*)&inputs0, (TfLiteIntArray*)&outputs0, const_cast<void*>(static_cast<const void*>(&opdata0)), OP_RESHAPE, },
  { (TfLiteIntArray*)&inputs1, (TfLiteIntArray*)&outputs1, const_cast<void*>(static_cast<const void*>(&opdata1)), OP_CONV_2D, },
  { (TfLiteIntArray*)&inputs2, (TfLiteIntArray*)&outputs2, const_cast<void*>(static_cast<const void*>(&opdata2)), OP_RESHAPE, },
  { (TfLiteIntArray*)&inputs3, (TfLiteIntArray*)&outputs3, const_cast<void*>(static_cast<const void*>(&opdata3)), OP_MAX_POOL_2D, },
  { (TfLiteIntArray*)&inputs4, (TfLiteIntArray*)&outputs4, const_cast<void*>(static_cast<const void*>(&opdata4)), OP_RESHAPE, },
  { (TfLiteIntArray*)&inputs5, (TfLiteIntArray*)&outputs5, const_cast<void*>(static_cast<const void*>(&opdata5)), OP_CONV_2D, },
  { (TfLiteIntArray*)&inputs6, (TfLiteIntArray*)&outputs6, const_cast<void*>(static_cast<const void*>(&opdata6)), OP_RESHAPE, },
  { (TfLiteIntArray*)&inputs7, (TfLiteIntArray*)&outputs7, const_cast<void*>(static_cast<const void*>(&opdata7)), OP_MAX_POOL_2D, },
  { (TfLiteIntArray*)&inputs8, (TfLiteIntArray*)&outputs8, const_cast<void*>(static_cast<const void*>(&opdata8)), OP_RESHAPE, },
  { (TfLiteIntArray*)&inputs9, (TfLiteIntArray*)&outputs9, const_cast<void*>(static_cast<const void*>(&opdata9)), OP_FULLY_CONNECTED, },
  { (TfLiteIntArray*)&inputs10, (TfLiteIntArray*)&outputs10, const_cast<void*>(static_cast<const void*>(&opdata10)), OP_SOFTMAX, },
};
static void* overflow_buffers[EI_MAX_OVERFLOW_BUFFER_COUNT];
static size_t overflow_buffers_ix = 0;
static void * AllocatePersistentBuffer(struct TfLiteContext* ctx,
                                       size_t bytes) {
  void *ptr;
  if (current_location - bytes < tensor_boundary) {
    if (overflow_buffers_ix > EI_MAX_OVERFLOW_BUFFER_COUNT - 1) {
      ei_printf("ERR: Failed to allocate persistent buffer of size %d, does not fit in tensor arena and reached EI_MAX_OVERFLOW_BUFFER_COUNT\n",
        (int)bytes);
      return NULL;
    }

    // OK, this will look super weird, but.... we have CMSIS-NN buffers which
    // we cannot calculate beforehand easily.
    ptr = ei_calloc(bytes, 1);
    if (ptr == NULL) {
      ei_printf("ERR: Failed to allocate persistent buffer of size %d\n", (int)bytes);
      return NULL;
    }
    overflow_buffers[overflow_buffers_ix++] = ptr;
    return ptr;
  }

  current_location -= bytes;

  ptr = current_location;
  memset(ptr, 0, bytes);

  return ptr;
}
typedef struct {
  size_t bytes;
  void *ptr;
} scratch_buffer_t;
static scratch_buffer_t scratch_buffers[EI_MAX_SCRATCH_BUFFER_COUNT];
static size_t scratch_buffers_ix = 0;

static TfLiteStatus RequestScratchBufferInArena(struct TfLiteContext* ctx, size_t bytes,
                                                int* buffer_idx) {
  if (scratch_buffers_ix > EI_MAX_SCRATCH_BUFFER_COUNT - 1) {
    ei_printf("ERR: Failed to allocate scratch buffer of size %d, reached EI_MAX_SCRATCH_BUFFER_COUNT\n",
      (int)bytes);
    return kTfLiteError;
  }

  scratch_buffer_t b;
  b.bytes = bytes;

  b.ptr = AllocatePersistentBuffer(ctx, b.bytes);
  if (!b.ptr) {
    ei_printf("ERR: Failed to allocate scratch buffer of size %d\n",
      (int)bytes);
    return kTfLiteError;
  }

  scratch_buffers[scratch_buffers_ix] = b;
  *buffer_idx = scratch_buffers_ix;

  scratch_buffers_ix++;

  return kTfLiteOk;
}

static void* GetScratchBuffer(struct TfLiteContext* ctx, int buffer_idx) {
  if (buffer_idx > (int)scratch_buffers_ix) {
    return NULL;
  }
  return scratch_buffers[buffer_idx].ptr;
}

static TfLiteTensor* GetTensor(const struct TfLiteContext* context,
                               int tensor_idx) {
  return &tflTensors[tensor_idx];
}

static TfLiteEvalTensor* GetEvalTensor(const struct TfLiteContext* context,
                                       int tensor_idx) {
  return &tflEvalTensors[tensor_idx];
}

} // namespace

TfLiteStatus trained_model_init( void*(*alloc_fnc)(size_t,size_t) ) {
#ifdef EI_CLASSIFIER_ALLOCATION_HEAP
  tensor_arena = (uint8_t*) alloc_fnc(16, kTensorArenaSize);
  if (!tensor_arena) {
    ei_printf("ERR: failed to allocate tensor arena\n");
    return kTfLiteError;
  }
#else
  memset(tensor_arena, 0, kTensorArenaSize);
#endif
  tensor_boundary = tensor_arena;
  current_location = tensor_arena + kTensorArenaSize;
  ctx.AllocatePersistentBuffer = &AllocatePersistentBuffer;
  ctx.RequestScratchBufferInArena = &RequestScratchBufferInArena;
  ctx.GetScratchBuffer = &GetScratchBuffer;
  ctx.GetTensor = &GetTensor;
  ctx.GetEvalTensor = &GetEvalTensor;
  ctx.tensors = tflTensors;
  ctx.tensors_size = 23;
  for (size_t i = 0; i < 23; ++i) {
    tflTensors[i].type = tensorData[i].type;
    tflEvalTensors[i].type = tensorData[i].type;
    tflTensors[i].is_variable = 0;

#if defined(EI_CLASSIFIER_ALLOCATION_HEAP)
    tflTensors[i].allocation_type = tensorData[i].allocation_type;
#else
    tflTensors[i].allocation_type = (tensor_arena <= tensorData[i].data && tensorData[i].data < tensor_arena + kTensorArenaSize) ? kTfLiteArenaRw : kTfLiteMmapRo;
#endif
    tflTensors[i].bytes = tensorData[i].bytes;
    tflTensors[i].dims = tensorData[i].dims;
    tflEvalTensors[i].dims = tensorData[i].dims;

#if defined(EI_CLASSIFIER_ALLOCATION_HEAP)
    if(tflTensors[i].allocation_type == kTfLiteArenaRw){
      uint8_t* start = (uint8_t*) ((uintptr_t)tensorData[i].data + (uintptr_t) tensor_arena);

     tflTensors[i].data.data =  start;
     tflEvalTensors[i].data.data =  start;
    }
    else {
       tflTensors[i].data.data = tensorData[i].data;
       tflEvalTensors[i].data.data = tensorData[i].data;
    }
#else
    tflTensors[i].data.data = tensorData[i].data;
    tflEvalTensors[i].data.data = tensorData[i].data;
#endif // EI_CLASSIFIER_ALLOCATION_HEAP
    tflTensors[i].quantization = tensorData[i].quantization;
    if (tflTensors[i].quantization.type == kTfLiteAffineQuantization) {
      TfLiteAffineQuantization const* quant = ((TfLiteAffineQuantization const*)(tensorData[i].quantization.params));
      tflTensors[i].params.scale = quant->scale->data[0];
      tflTensors[i].params.zero_point = quant->zero_point->data[0];
    }
    if (tflTensors[i].allocation_type == kTfLiteArenaRw) {
      auto data_end_ptr = (uint8_t*)tflTensors[i].data.data + tensorData[i].bytes;
      if (data_end_ptr > tensor_boundary) {
        tensor_boundary = data_end_ptr;
      }
    }
  }
  if (tensor_boundary > current_location /* end of arena size */) {
    ei_printf("ERR: tensor arena is too small, does not fit model - even without scratch buffers\n");
    return kTfLiteError;
  }
  registrations[OP_RESHAPE] = Register_RESHAPE();
  registrations[OP_CONV_2D] = Register_CONV_2D();
  registrations[OP_MAX_POOL_2D] = Register_MAX_POOL_2D();
  registrations[OP_FULLY_CONNECTED] = Register_FULLY_CONNECTED();
  registrations[OP_SOFTMAX] = Register_SOFTMAX();

  for (size_t i = 0; i < 11; ++i) {
    tflNodes[i].inputs = nodeData[i].inputs;
    tflNodes[i].outputs = nodeData[i].outputs;
    tflNodes[i].builtin_data = nodeData[i].builtin_data;
tflNodes[i].custom_initial_data = nullptr;
      tflNodes[i].custom_initial_data_size = 0;
if (registrations[nodeData[i].used_op_index].init) {
      tflNodes[i].user_data = registrations[nodeData[i].used_op_index].init(&ctx, (const char*)tflNodes[i].builtin_data, 0);
    }
  }
  for (size_t i = 0; i < 11; ++i) {
    if (registrations[nodeData[i].used_op_index].prepare) {
      TfLiteStatus status = registrations[nodeData[i].used_op_index].prepare(&ctx, &tflNodes[i]);
      if (status != kTfLiteOk) {
        return status;
      }
    }
  }
  return kTfLiteOk;
}

static const int inTensorIndices[] = {
  0, 
};
TfLiteTensor* trained_model_input(int index) {
  return &ctx.tensors[inTensorIndices[index]];
}

static const int outTensorIndices[] = {
  22, 
};
TfLiteTensor* trained_model_output(int index) {
  return &ctx.tensors[outTensorIndices[index]];
}

TfLiteStatus trained_model_invoke() {
  for (size_t i = 0; i < 11; ++i) {
    TfLiteStatus status = registrations[nodeData[i].used_op_index].invoke(&ctx, &tflNodes[i]);

#if EI_CLASSIFIER_PRINT_STATE
    ei_printf("layer %lu\n", i);
    ei_printf("    inputs:\n");
    for (size_t ix = 0; ix < tflNodes[i].inputs->size; ix++) {
      auto d = tensorData[tflNodes[i].inputs->data[ix]];

      size_t data_ptr = (size_t)d.data;

      if (d.allocation_type == kTfLiteArenaRw) {
        data_ptr = (size_t)tensor_arena + data_ptr;
      }

      if (d.type == TfLiteType::kTfLiteInt8) {
        int8_t* data = (int8_t*)data_ptr;
        ei_printf("        %lu (%zu bytes, ptr=%p, alloc_type=%d, type=%d): ", ix, d.bytes, data, (int)d.allocation_type, (int)d.type);
        for (size_t jx = 0; jx < d.bytes; jx++) {
          ei_printf("%d ", data[jx]);
        }
      }
      else {
        float* data = (float*)data_ptr;
        ei_printf("        %lu (%zu bytes, ptr=%p, alloc_type=%d, type=%d): ", ix, d.bytes, data, (int)d.allocation_type, (int)d.type);
        for (size_t jx = 0; jx < d.bytes / 4; jx++) {
          ei_printf("%f ", data[jx]);
        }
      }
      ei_printf("\n");
    }
    ei_printf("\n");

    ei_printf("    outputs:\n");
    for (size_t ix = 0; ix < tflNodes[i].outputs->size; ix++) {
      auto d = tensorData[tflNodes[i].outputs->data[ix]];

      size_t data_ptr = (size_t)d.data;

      if (d.allocation_type == kTfLiteArenaRw) {
        data_ptr = (size_t)tensor_arena + data_ptr;
      }

      if (d.type == TfLiteType::kTfLiteInt8) {
        int8_t* data = (int8_t*)data_ptr;
        ei_printf("        %lu (%zu bytes, ptr=%p, alloc_type=%d, type=%d): ", ix, d.bytes, data, (int)d.allocation_type, (int)d.type);
        for (size_t jx = 0; jx < d.bytes; jx++) {
          ei_printf("%d ", data[jx]);
        }
      }
      else {
        float* data = (float*)data_ptr;
        ei_printf("        %lu (%zu bytes, ptr=%p, alloc_type=%d, type=%d): ", ix, d.bytes, data, (int)d.allocation_type, (int)d.type);
        for (size_t jx = 0; jx < d.bytes / 4; jx++) {
          ei_printf("%f ", data[jx]);
        }
      }
      ei_printf("\n");
    }
    ei_printf("\n");
#endif // EI_CLASSIFIER_PRINT_STATE

    if (status != kTfLiteOk) {
      return status;
    }
  }
  return kTfLiteOk;
}

TfLiteStatus trained_model_reset( void (*free_fnc)(void* ptr) ) {
#ifdef EI_CLASSIFIER_ALLOCATION_HEAP
  free_fnc(tensor_arena);
#endif

  // scratch buffers are allocated within the arena, so just reset the counter so memory can be reused
  scratch_buffers_ix = 0;

  // overflow buffers are on the heap, so free them first
  for (size_t ix = 0; ix < overflow_buffers_ix; ix++) {
    ei_free(overflow_buffers[ix]);
  }
  overflow_buffers_ix = 0;
  return kTfLiteOk;
}
